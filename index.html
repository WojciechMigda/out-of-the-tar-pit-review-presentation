<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js - The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

<section>
  <h1>"Out of the Tar Pit"</h1>
  <h3>review</h3>
  <p>
  <small>Created by Wojciech Migda</small>
  </p>
</section>

<section>
  <h2>"Out of the Tar Pit"</h2>

  <p><small><a href="http://shaffner.us/cs/papers/tarpit.pdf">http://shaffner.us/cs/papers/tarpit.pdf</a></small></p>

  <p>Ben Moseley <a href="mailto:ben@moseley.name">ben@moseley.name</a>
  <p>Peter Marks <a href="mailto:public@indigomail.net">public@indigomail.net</a>

  <p><small>February 6, 2006</small></p>
</section>

<section>

  <h2>Software Crisis</h2>

  <p>1968</p>

  <p>large-scale software systems</p>
  <p>analysis and reasoning about the system</p>

</section>

<section>

  <h2>Software Crisis</h2>

  <p>the problem is</p>
  <p>COMPLEXITY</p>
  <br/>
  <p>due to handling of</p>
  <p>STATE</p>

</section>

<section>

  <h2>Complexity</h2>

  <p>Unmanageable complexity:</p>
  <br/>
  <p>unreliability,</p>
  <p>late delivery,</p>
  <p>lack of security,</p>
  <p>poor performance.</p>

</section>

<section>

  <h2>Complexity</h2>

  <p>1991, Dijkstra</p>
  <br/>
  <p>“...we have to keep it crisp, disentangled, and simple if we refuse to be crushed by the complexities of our own making...”
</p>

</section>

<section>

  <h2>Complexity</h2>

  <p>1980, Hoare, Turing award speech:</p>
  <br/>
  <p>“I conclude that there are two ways of
constructing a software
design:<br/> One way is to make it so simple
that there are obviously
no deficiencies and the other way is to
make it so complicated
that there are no obvious deficiencies.
The first method is far
more difficult.”
</p>

</section>

<section>

  <h2>Understanding the system</h2>

  <p>by testing,
  </p>
  <p>by informal reasoning.
  </p>

</section>

<section>

  <h2>Understanding the system</h2>

  <p>Testing:
  </p>
  <p>there are inherent limits to what can
be achieved by testing.
  </p>

</section>

<section>

  <h2>Understanding the system</h2>

  <p>Informal reasoning:
  </p>
  <p>is always used
by virtue of being
an inherent part of the development process.
  </p>

</section>

<section>

  <h2>Understanding the system</h2>

  <p>improvements in informal reasoning will lead to<br/> <i>less
errors being created</i>
  </p>
  <p>whilst all that improvements in testing can do is to lead
to<br/> <i>more errors being detected.</i>
  </p>

</section>

<section>

  <h2>Understanding the system</h2>

  <p>1972, Dijkstra, Turing award speech:</p>
  <br/>
  <p>“Those who want really reliable software will discover that they
must find means of avoiding the majority of bugs to start with.”
</p>

</section>

<section>
  <h2>Understanding the system</h2>

  <p>Problem with testing:
  </p>
  <p>
  <i>have
you performed the right tests?</i>
  </p>
  <p>one
particular set of inputs tells you nothing at all about the behaviour of the
system or component when it is given a different set of inputs.
  </p>

</section>


<section>

  <h2>Understanding the system</h2>

  <p>1971, Dijkstra:</p>
  <br/>
  <p>“testing is hopelessly inadequate....(it) can be used very effectively to show the presence of bugs<br/> but never to show their absence.”
</p>

</section>

<section>

  <h2>Understanding the system</h2>

  <p>Rely on testing at your peril.
</p>

</section>

<section>

  <h2>State vs. testing</h2>

  <p>Clean slate approach:
</p>
  <p>support desk's <i>silver bullet</i>,
</p>
  <p>common approach to testing a stateful system:<br/> ill-founded
assumption that the system will perform the same way every time the test is run with the same inputs regardless of
its hidden internal state.
</p>

</section>

<section>

  <h2>State vs. testing</h2>

  <p>We are left with very little about which we can be certain
if the system/component under scrutiny is of a stateful nature.
</p>
  <p>State affects all types of testing — from system-level testing
  through to component-level or unit testing.
</p>

</section>

<section>

  <h2>State vs. informal reasoning</h2>

  <p>Often a case-by-case mental simulation of behaviour,
</p>
  <p>will work for simple cases,
</p>
  <p>but exponential rate at which the number of possible states grows! FAIL.
</p>

</section>

<section>

  <h2>State vs. informal reasoning</h2>

  <p>We hope that the procedures which aren’t themselves stateful will be more easy
to comprehend.
</p>
  <p>This is largely not the case.
</p>

</section>

<section>

  <h2>Types of complexity: Control</h2>

  <p>Orderer in which things happen.
</p>
  <p>Traditional languages - order of statements in the source code, branching, and subroutines.
</p>

</section>

<section>

  <h2>Types of complexity: Control</h2>

  <p>When control is an implicit part of the language
then every single piece of program must be understood
in the context order even when it is not really relevant.
</p>
  <p>Programmer is forced to focus on how the system should work rather than
  simply what is desired (overspecification, artificial ordering).
</p>

</section>

<section>

  <h2>Types of complexity: Control</h2>

  <p>Concurrency
</p>
  <p>Shared state and explicit synchronization.
</p>
  <p>Severe impact on testing, even if we enforce consistent starting state then there is no guarantee
  that the system will behave the same way during the next run.
</p>

</section>

<section>

  <h2>Types of complexity: Code Volume</h2>

  <p>Complexity grows in a non-linear manner when code size increases.
</p>

</section>

<section>

  <h2>Types of complexity: Other</h2>

  <p>Code redundancy (complexity breeds complexity), dead code, unnecessary abstraction (particularly data abstraction), missed abstraction,
  poor modularity, poor documentation.
</p>
  <p>Power corrupts - the more powerful a language, the harder it is to understand systems constructed in it.
</p>

</section>

<section>

  <h2>Managing complexity</h2>

  <p>Functional languages
</p>
  <p>referential transparency — when supplied with a given set of arguments a function will always return exactly the same result.
</p>

</section>

<section>

  <h2>Managing complexity</h2>

  <p>There is no reason why
the functional style of programming cannot be adopted in stateful languages
(e.g. imperative ones). More generally, whatever the language being used — there are large benefits
to be had from avoiding hidden, implicit, mutable state.
</p>

</section>

<section>

  <h2>Accidents and Essence</h2>

  <p>Essential and accidental complexity of the problem.
</p>

</section>

<section>

  <h2>Accidents and Essence</h2>

  <p>Essential complexity:
</p>
  <p>inherent in the solved problem itself (as seen from the user perspective),
</p>
  <p>must be dealt with by the development team even in the perfect world,
</p>

</section>

<section>

  <h2>Accidents and Essence</h2>

  <p>Accidental complexity:
</p>
  <p>stems from a real-world implmentation of the solution to the problem,
</p>
  <p>performance tweaks, poor language and infrastructure,
</p>

</section>

<section>
  <h1>THE END</h1>
  <h3>BY Wojciech Migda</h3>
</section>


			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
